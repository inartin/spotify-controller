<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Clock & Now Playing</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- SVG Analog Clock Implementation -->
    <style>
        :root {
            /* Fluid spacing system */
            --spacing-xs: clamp(4px, 0.8vw, 8px);
            --spacing-sm: clamp(6px, 1.2vw, 12px);
            --spacing-md: clamp(12px, 2vw, 20px);
            --spacing-lg: clamp(16px, 2.5vw, 30px);
            --spacing-xl: clamp(20px, 3vw, 40px);
            
            /* Fluid font sizes */
            --font-xs: clamp(10px, 1.5vw, 14px);
            --font-sm: clamp(12px, 2vw, 16px);
            --font-md: clamp(14px, 2.5vw, 18px);
            --font-lg: clamp(16px, 3vw, 24px);
            --font-xl: clamp(20px, 3.5vw, 28px);
            --font-xxl: clamp(24px, 4vw, 36px);
        }

        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrolling for full dashboard */
        }

        body {
            font-family: 'SF Pro Display', -webkit-system-font, 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: #000000;
            color: white;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #login-container {
            text-align: center;
            padding: var(--spacing-md);
            max-width: min(90%, 600px);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        /* Keep the existing background system */
        body {
            --album-bg: none;
            --album-bg-next: none;
            --bg-opacity: 1;
            transition: --bg-opacity 0.5s ease-in-out;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: var(--album-bg);
            background-size: cover;
            background-position: center;
            filter: blur(20px) brightness(0.4);
            opacity: var(--bg-opacity);
            z-index: -1;
            transform: scale(1.1);
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: var(--album-bg-next);
            background-size: cover;
            background-position: center;
            filter: blur(20px) brightness(0.4);
            opacity: calc(1 - var(--bg-opacity));
            z-index: -1;
            transform: scale(1.1);
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #dashboard {
            display: none;
            width: 100%;
            height: 100vh;
            padding: var(--spacing-xl);
            box-sizing: border-box;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-xl);
            align-items: center;
            z-index: 1;
        }

        .hidden {
            display: none !important;
        }

        /* Login Button Styling */
        button {
            background-color: rgba(29, 185, 84, 0.2);
            color: white;
            border: none;
            padding: clamp(12px, 2vw, 20px) clamp(20px, 4vw, 36px);
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            margin: var(--spacing-sm);
            font-size: var(--font-md);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        button:hover,
        button:active {
            background-color: rgba(30, 215, 95, 0.3);
            transform: scale(1.05);
        }

        /* Clock Section */
        #clock-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        #clock-container {
            position: relative;
            margin-bottom: var(--spacing-lg);
        }

        #analog-clock {
            width: clamp(180px, 28vw, 400px);
            height: clamp(180px, 28vw, 400px);
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #digital-time {
            font-size: var(--font-lg);
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            letter-spacing: 2px;
            margin-top: var(--spacing-md);
        }

        #date-display {
            font-size: var(--font-xl);
            font-weight: 300;
            color: rgba(255, 255, 255, 0.6);
            text-align: center;
            margin-top: var(--spacing-sm);
        }

        /* Spotify Section */
        #spotify-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: var(--spacing-xl);
        }

        .now-playing-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: var(--spacing-xl);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            max-width: min(500px, 90vw);
            width: 100%;
        }

        #album-art {
            width: clamp(140px, 20vw, 250px);
            height: clamp(140px, 20vw, 250px);
            box-shadow: 0 8px 60px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: var(--spacing-lg);
        }

        #track-name {
            font-size: var(--font-xxl);
            font-weight: 600;
            margin-bottom: var(--spacing-sm);
            line-height: 1.2;
            word-break: break-word;
            hyphens: auto;
        }

        #artist-name {
            font-size: var(--font-lg);
            color: rgba(255, 255, 255, 0.7);
            font-weight: 400;
            margin-bottom: var(--spacing-lg);
            word-break: break-word;
        }

        #album-name {
            font-size: var(--font-md);
            color: rgba(255, 255, 255, 0.5);
            font-weight: 300;
            font-style: italic;
            margin-bottom: var(--spacing-lg);
            word-break: break-word;
        }

        /* Progress Section */
        #progress-container {
            width: 100%;
            margin-top: var(--spacing-md);
        }

        #progress-bar {
            width: 100%;
            cursor: pointer;
            height: clamp(6px, 1vw, 10px);
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            outline: none;
            margin-bottom: var(--spacing-sm);
        }

        #progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: clamp(14px, 2vw, 20px);
            height: clamp(14px, 2vw, 20px);
            background: #1DB954;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: background 0.3s ease, transform 0.1s ease;
        }

        #progress-bar::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        #progress-bar::-moz-range-thumb {
            width: clamp(14px, 2vw, 20px);
            height: clamp(14px, 2vw, 20px);
            background: #1DB954;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: background 0.3s ease;
        }

        /* Progress bar states for different play states */
        #progress-bar.paused::-webkit-slider-thumb {
            background: rgba(255, 255, 255, 0.6);
        }

        #progress-bar.paused::-moz-range-thumb {
            background: rgba(255, 255, 255, 0.6);
        }

        #progress-bar.not-playing::-webkit-slider-thumb {
            background: rgba(255, 255, 255, 0.3);
        }

        #progress-bar.not-playing::-moz-range-thumb {
            background: rgba(255, 255, 255, 0.3);
        }

        #time-display {
            display: flex;
            justify-content: space-between;
            font-size: var(--font-xs);
            color: rgba(255, 255, 255, 0.6);
            font-weight: 300;
            letter-spacing: 0.5px;
        }

        .setup-instructions {
            background-color: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(10px);
            padding: var(--spacing-md);
            border-radius: 12px;
            margin-bottom: var(--spacing-md);
            max-width: 100%;
            text-align: left;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setup-instructions code {
            background-color: rgba(18, 18, 18, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
            word-break: break-all;
        }

        /* Enhanced Mobile Responsiveness with better scaling */
        
        /* Large screens */
        @media (min-width: 1400px) {
            #dashboard {
                max-width: 1200px;
                margin: 0 auto;
            }
        }

        /* Medium screens - laptops */
        @media (max-width: 1400px) {
            #dashboard {
                gap: var(--spacing-lg);
                padding: var(--spacing-lg);
            }
        }

        /* Small laptops and large tablets */
        @media (max-width: 1200px) {
            #dashboard {
                gap: var(--spacing-md);
                padding: var(--spacing-md);
            }
            
            #analog-clock {
                width: clamp(150px, 25vw, 300px);
                height: clamp(150px, 25vw, 300px);
            }
            
            #album-art {
                width: clamp(120px, 18vw, 200px);
                height: clamp(120px, 18vw, 200px);
            }
        }

        /* Tablets in landscape and portrait */
        @media (max-width: 1024px) {
            #dashboard {
                gap: var(--spacing-sm);
                padding: var(--spacing-sm);
            }

            #analog-clock {
                width: clamp(130px, 22vw, 250px);
                height: clamp(130px, 22vw, 250px);
            }

            #album-art {
                width: clamp(100px, 16vw, 180px);
                height: clamp(100px, 16vw, 180px);
            }
            
            .now-playing-container {
                padding: var(--spacing-md);
                max-width: 90vw;
            }
        }

        /* Small tablets and large phones in landscape */
        @media (max-width: 900px) {
            #dashboard {
                gap: var(--spacing-xs);
                padding: var(--spacing-xs);
            }

            #analog-clock {
                width: clamp(120px, 20vw, 220px);
                height: clamp(120px, 20vw, 220px);
            }

            #album-art {
                width: clamp(90px, 15vw, 160px);
                height: clamp(90px, 15vw, 160px);
            }
        }

        /* Switch to single column for smaller screens */
        @media (max-width: 768px) {
            #dashboard {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
                padding: var(--spacing-xs);
                gap: var(--spacing-xs);
                overflow-y: auto;
                height: auto;
                min-height: 100vh;
            }

            #clock-section,
            #spotify-section {
                height: auto;
                min-height: auto;
                padding: var(--spacing-sm);
            }

            #analog-clock {
                width: clamp(140px, 35vw, 250px);
                height: clamp(140px, 35vw, 250px);
            }

            #album-art {
                width: clamp(120px, 30vw, 200px);
                height: clamp(120px, 30vw, 200px);
            }

            .now-playing-container {
                padding: var(--spacing-sm);
                max-width: 95vw;
            }
        }

        /* Small mobile devices */
        @media (max-width: 600px) {
            #dashboard {
                padding: 8px;
                gap: 8px;
            }

            #analog-clock {
                width: clamp(120px, 32vw, 200px);
                height: clamp(120px, 32vw, 200px);
            }

            #album-art {
                width: clamp(100px, 28vw, 160px);
                height: clamp(100px, 28vw, 160px);
            }

            .now-playing-container {
                padding: 12px;
            }
        }

        /* Very small mobile devices */
        @media (max-width: 480px) {
            #dashboard {
                padding: 6px;
                gap: 6px;
            }

            #analog-clock {
                width: clamp(100px, 30vw, 180px);
                height: clamp(100px, 30vw, 180px);
            }

            #album-art {
                width: clamp(80px, 25vw, 140px);
                height: clamp(80px, 25vw, 140px);
            }

            .now-playing-container {
                padding: 10px;
            }
        }

        /* Ultra-wide screens */
        @media (min-width: 1920px) {
            #dashboard {
                max-width: 1800px;
                margin: 0 auto;
                padding: var(--spacing-xl) 5vw;
            }
        }

        /* Landscape orientation specific adjustments */
        @media (orientation: landscape) and (max-height: 600px) {
            #dashboard {
                grid-template-columns: 1fr 1fr;
                align-items: stretch;
            }
            
            #clock-section,
            #spotify-section {
                padding: var(--spacing-sm);
            }
            
            #analog-clock {
                width: clamp(150px, 25vh, 280px);
                height: clamp(150px, 25vh, 280px);
            }
            
            #album-art {
                width: clamp(120px, 20vh, 200px);
                height: clamp(120px, 20vh, 200px);
            }
        }
    </style>
</head>

<body>
    <div id="login-container">
        <h1>Dashboard - Clock & Now Playing</h1>
        <div class="setup-instructions">
            <h2>First-time Setup:</h2>
            <ol>
                <li>Create a Spotify Developer application at
                    <a href="https://developer.spotify.com/dashboard"
                        target="_blank">developer.spotify.com/dashboard</a>
                </li>
                <li>Set the Redirect URI to your current URL: <code id="redirect-uri">loading...</code>
                    <button id="copy-uri" style="padding: 2px 8px; margin-left: 5px;">Copy</button>
                </li>
                <li>Copy your Client ID</li>
                <li>You can either:
                    <ul>
                        <li>Enter it below and click "Save Client ID", or</li>
                        <li>Append it to the URL like: <code id="url-example">loading...</code></li>
                    </ul>
                </li>
            </ol>
        </div>
        <div>
            <input type="text" id="client-id-input" placeholder="Enter your Spotify Client ID">
            <button id="save-client-id">Save Client ID</button>
        </div>
        <button id="login-button" class="hidden">Connect to Spotify</button>
    </div>

    <div id="dashboard">
        <!-- Clock Section -->
        <div id="clock-section">
            <div id="clock-container">
                <svg id="analog-clock" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
                    <!-- Clock face -->
                    <circle cx="100" cy="100" r="95" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="2"/>
                    
                    <!-- Hour markers -->
                    <g id="hour-markers">
                        <!-- 12, 3, 6, 9 markers (larger) -->
                        <line x1="100" y1="10" x2="100" y2="25" stroke="rgba(255,255,255,0.8)" stroke-width="3" stroke-linecap="round"/>
                        <line x1="190" y1="100" x2="175" y2="100" stroke="rgba(255,255,255,0.8)" stroke-width="3" stroke-linecap="round"/>
                        <line x1="100" y1="190" x2="100" y2="175" stroke="rgba(255,255,255,0.8)" stroke-width="3" stroke-linecap="round"/>
                        <line x1="10" y1="100" x2="25" y2="100" stroke="rgba(255,255,255,0.8)" stroke-width="3" stroke-linecap="round"/>
                        
                        <!-- Other hour markers -->
                        <line x1="150" y1="23.4" x2="144.6" y2="33.4" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round"/>
                        <line x1="176.6" y1="50" x2="166.6" y2="55.4" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round"/>
                        <line x1="176.6" y1="150" x2="166.6" y2="144.6" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round"/>
                        <line x1="150" y1="176.6" x2="144.6" y2="166.6" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round"/>
                        <line x1="50" y1="176.6" x2="55.4" y2="166.6" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round"/>
                        <line x1="23.4" y1="150" x2="33.4" y2="144.6" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round"/>
                        <line x1="23.4" y1="50" x2="33.4" y2="55.4" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round"/>
                        <line x1="50" y1="23.4" x2="55.4" y2="33.4" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linecap="round"/>
                    </g>
                    
                    <!-- Clock hands -->
                    <line id="hour-hand" x1="100" y1="100" x2="100" y2="60" stroke="#ffffff" stroke-width="6" stroke-linecap="round"/>
                    <line id="minute-hand" x1="100" y1="100" x2="100" y2="35" stroke="#ffffff" stroke-width="4" stroke-linecap="round"/>
                    <line id="second-hand" x1="100" y1="100" x2="100" y2="25" stroke="#1DB954" stroke-width="2" stroke-linecap="round"/>
                    
                    <!-- Center dot -->
                    <circle cx="100" cy="100" r="6" fill="#ffffff"/>
                    <circle cx="100" cy="100" r="3" fill="#1DB954"/>
                </svg>
            </div>
            <div id="date-display">Monday, January 1</div>
        </div>

        <!-- Spotify Section -->
        <div id="spotify-section">
            <div class="now-playing-container">
                <div id="album-art"></div>
                <div id="track-name">Not Playing</div>
                <div id="artist-name">-</div>
                <div id="album-name"></div>
                
                <!-- Progress Section -->
                <div id="progress-container">
                    <input type="range" id="progress-bar" value="0" style="width: 100%;">
                    <div id="time-display">
                        <span id="current-time">0:00</span>
                        <span id="total-time">0:00</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Authentication & Authorization
        const SPOTIFY_AUTH_ENDPOINT = 'https://accounts.spotify.com/authorize';
        const SPOTIFY_TOKEN_ENDPOINT = 'https://accounts.spotify.com/api/token';
        const SPOTIFY_API_ENDPOINT = 'https://api.spotify.com/v1';
        const SCOPES = [
            'user-read-private',
            'user-read-currently-playing',
            'user-read-playback-state',
            'user-modify-playback-state'
        ];

        // Generate a random string for the state parameter
        function generateRandomString(length) {
            let text = '';
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }

        // Generate a code verifier (random string between 43-128 chars)
        function generateCodeVerifier() {
            return generateRandomString(128);
        }

        // Generate code challenge from verifier using SHA-256
        async function generateCodeChallenge(codeVerifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(codeVerifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);

            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/=/g, '')
                .replace(/\+/g, '-')
                .replace(/\//g, '_');
        }

        // DOM Elements
        const loginContainer = document.getElementById('login-container');
        const dashboard = document.getElementById('dashboard');
        const clientIdInput = document.getElementById('client-id-input');
        const saveClientIdButton = document.getElementById('save-client-id');
        const loginButton = document.getElementById('login-button');
        const redirectUriElement = document.getElementById('redirect-uri');
        const albumArt = document.getElementById('album-art');
        const trackName = document.getElementById('track-name');
        const artistName = document.getElementById('artist-name');
        const albumName = document.getElementById('album-name');
        const progressBar = document.getElementById('progress-bar');
        const currentTimeDisplay = document.getElementById('current-time');
        const totalTimeDisplay = document.getElementById('total-time');
        const dateDisplay = document.getElementById('date-display');

        // Get the base URL for redirect URI
        const baseUrl = window.location.origin + window.location.pathname;

        // Set the redirect URI text and URL example
        redirectUriElement.textContent = baseUrl;
        const urlExample = document.getElementById('url-example');
        urlExample.textContent = baseUrl + '#client_id=YOUR_CLIENT_ID';

        // Check URL hash for client ID first
        let clientId;
        const urlParams = new URLSearchParams(window.location.hash.substring(1));
        const urlClientId = urlParams.get('client_id');

        if (urlClientId) {
            clientId = urlClientId;
            localStorage.setItem('spotify_client_id', clientId);
            history.replaceState(null, null, window.location.pathname);
            clientIdInput.value = clientId;
            loginButton.classList.remove('hidden');
        } else {
            clientId = localStorage.getItem('spotify_client_id');
            if (clientId) {
                clientIdInput.value = clientId;
                loginButton.classList.remove('hidden');
            }
        }

        // Save Client ID to localStorage
        saveClientIdButton.addEventListener('click', () => {
            const newClientId = clientIdInput.value.trim();
            if (newClientId) {
                localStorage.setItem('spotify_client_id', newClientId);
                clientId = newClientId;
                loginButton.classList.remove('hidden');
                alert('Client ID saved successfully!');
            } else {
                alert('Please enter a valid Client ID');
            }
        });

        // Handle Login
        loginButton.addEventListener('click', async () => {
            if (!clientId) {
                alert('Please enter your Spotify Client ID first');
                return;
            }

            const codeVerifier = generateCodeVerifier();
            localStorage.setItem('spotify_code_verifier', codeVerifier);

            const codeChallenge = await generateCodeChallenge(codeVerifier);

            const state = generateRandomString(16);
            localStorage.setItem('spotify_auth_state', state);

            const authUrl = new URL(SPOTIFY_AUTH_ENDPOINT);
            const params = {
                client_id: clientId,
                redirect_uri: baseUrl,
                scope: SCOPES.join(' '),
                response_type: 'code',
                code_challenge_method: 'S256',
                code_challenge: codeChallenge,
                state: state,
                show_dialog: true
            };

            authUrl.search = new URLSearchParams(params).toString();
            window.location.href = authUrl.toString();
        });

        // Parse query parameters from URL
        function getQueryParams() {
            const queryParams = {};
            const queryString = window.location.search.substring(1);

            if (!queryString) {
                return queryParams;
            }

            queryString.split('&').forEach(pair => {
                const [key, value] = pair.split('=');
                queryParams[key] = decodeURIComponent(value);
            });

            return queryParams;
        }

        // Exchange authorization code for an access token
        async function exchangeCodeForToken(code) {
            const clientId = localStorage.getItem('spotify_client_id');
            const codeVerifier = localStorage.getItem('spotify_code_verifier');

            if (!clientId || !codeVerifier) {
                throw new Error('Missing client ID or code verifier');
            }

            const params = new URLSearchParams();
            params.append('client_id', clientId);
            params.append('grant_type', 'authorization_code');
            params.append('code', code);
            params.append('redirect_uri', baseUrl);
            params.append('code_verifier', codeVerifier);

            const response = await fetch(SPOTIFY_TOKEN_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: params
            });

            if (!response.ok) {
                throw new Error(`Token request failed: ${response.status}`);
            }

            return await response.json();
        }

        // Initialize app
        async function initApp() {
            // Initialize the clock first
            initializeClock();

            const queryParams = getQueryParams();
            const code = queryParams.code;
            const state = queryParams.state;
            const error = queryParams.error;

            if (error) {
                console.error(`Authorization error: ${error}`);
                alert(`Authorization failed: ${error}`);
                return;
            }

            if (code) {
                try {
                    const currentUrl = new URL(window.location.href);
                    currentUrl.searchParams.delete('code');
                    currentUrl.searchParams.delete('state');
                    window.history.replaceState({}, document.title, currentUrl.toString());

                    const storedState = localStorage.getItem('spotify_auth_state');
                    if (state !== storedState) {
                        throw new Error('State mismatch, possible CSRF attack');
                    }

                    const data = await exchangeCodeForToken(code);

                    const accessToken = data.access_token;
                    const refreshToken = data.refresh_token;
                    const expiresIn = data.expires_in;
                    const tokenTimestamp = Date.now();

                    localStorage.setItem('spotify_access_token', accessToken);
                    localStorage.setItem('spotify_refresh_token', refreshToken);
                    localStorage.setItem('spotify_token_timestamp', tokenTimestamp);
                    localStorage.setItem('spotify_token_expires_in', expiresIn);

                    loginContainer.style.display = 'none';
                    dashboard.style.display = 'grid';

                    setupSpotify(accessToken);
                    return;
                } catch (error) {
                    console.error('Error exchanging code for token:', error);
                    alert(`Authentication error: ${error.message}`);
                }
            }

            // Check if we have a valid stored token
            const storedToken = localStorage.getItem('spotify_access_token');
            const storedTimestamp = localStorage.getItem('spotify_token_timestamp');
            const storedExpiresIn = localStorage.getItem('spotify_token_expires_in');

            if (storedToken && storedTimestamp && storedExpiresIn) {
                const now = Date.now();
                const elapsed = (now - storedTimestamp) / 1000;

                if (elapsed < storedExpiresIn) {
                    loginContainer.style.display = 'none';
                    dashboard.style.display = 'grid';
                    setupSpotify(storedToken);
                    return;
                } else {
                    try {
                        await refreshAccessToken();
                        loginContainer.style.display = 'none';
                        dashboard.style.display = 'grid';
                        setupSpotify(localStorage.getItem('spotify_access_token'));
                        return;
                    } catch (error) {
                        console.error('Error refreshing token:', error);
                    }
                }
            }

            loginContainer.style.display = 'block';
            dashboard.style.display = 'none';
        }

        // Refresh the access token using the refresh token
        async function refreshAccessToken() {
            const clientId = localStorage.getItem('spotify_client_id');
            const refreshToken = localStorage.getItem('spotify_refresh_token');

            if (!clientId || !refreshToken) {
                throw new Error('Missing client ID or refresh token');
            }

            try {
                const params = new URLSearchParams();
                params.append('client_id', clientId);
                params.append('grant_type', 'refresh_token');
                params.append('refresh_token', refreshToken);

                const response = await fetch(SPOTIFY_TOKEN_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: params
                });

                if (!response.ok) {
                    throw new Error(`Refresh token request failed: ${response.status}`);
                }

                const data = await response.json();

                localStorage.setItem('spotify_access_token', data.access_token);
                localStorage.setItem('spotify_token_timestamp', Date.now());
                localStorage.setItem('spotify_token_expires_in', data.expires_in);

                if (data.refresh_token) {
                    localStorage.setItem('spotify_refresh_token', data.refresh_token);
                }

                return data;
            } catch (error) {
                console.error('Error refreshing token:', error);
                throw error;
            }
        }

        // Clock functionality
        function initializeClock() {
            // Update digital time, date, and analog clock
            updateClock();
            setInterval(updateClock, 1000);
        }

        function updateClock() {
            const now = new Date();
            
            // Update date
            const dateString = now.toLocaleDateString('en-US', {
                weekday: 'long',
                month: 'long',
                day: 'numeric'
            });
            dateDisplay.textContent = dateString;

            // Update analog clock
            updateAnalogClock(now);
        }

        function updateAnalogClock(date) {
            const hours = date.getHours() % 12;
            const minutes = date.getMinutes();
            const seconds = date.getSeconds();

            // Calculate angles (in degrees)
            const secondAngle = (seconds * 6) - 90; // 6 degrees per second, -90 to start at 12
            const minuteAngle = (minutes * 6) + (seconds * 0.1) - 90; // 6 degrees per minute + smooth seconds
            const hourAngle = (hours * 30) + (minutes * 0.5) - 90; // 30 degrees per hour + smooth minutes

            // Get clock hands
            const hourHand = document.getElementById('hour-hand');
            const minuteHand = document.getElementById('minute-hand');
            const secondHand = document.getElementById('second-hand');

            // Apply rotations
            if (hourHand) {
                hourHand.style.transform = `rotate(${hourAngle}deg)`;
                hourHand.style.transformOrigin = '100px 100px';
            }
            if (minuteHand) {
                minuteHand.style.transform = `rotate(${minuteAngle}deg)`;
                minuteHand.style.transformOrigin = '100px 100px';
            }
            if (secondHand) {
                secondHand.style.transform = `rotate(${secondAngle}deg)`;
                secondHand.style.transformOrigin = '100px 100px';
                // Add smooth transition for second hand
                secondHand.style.transition = seconds === 0 ? 'none' : 'transform 0.1s ease-in-out';
            }
        }

        // Track state to avoid unnecessary UI updates
        let currentTrackId = null;
        let currentAlbumId = null;
        let currentProgressMs = 0;
        let currentPlayState = null;
        let isUpdatingBackground = false;
        let currentBackgroundUrl = null;

        // Format time from ms to M:SS
        function formatTime(ms) {
            if (isNaN(ms) || ms < 0) return "0:00";
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        // Update progress bar appearance based on play state
        function updateProgressBarState(isPlaying) {
            progressBar.classList.remove('paused', 'not-playing');
            
            if (isPlaying === null || isPlaying === undefined) {
                // Not playing anything
                progressBar.classList.add('not-playing');
            } else if (isPlaying === false) {
                // Paused
                progressBar.classList.add('paused');
            }
            // If isPlaying === true, no additional class needed (default green color)
        }

        // Timer for updating the playback position without API calls
        let playbackTimerId = null;

        function startPlaybackTimer() {
            // Clear any existing timer
            if (playbackTimerId) {
                clearInterval(playbackTimerId);
            }

            // Update playback position every second if music is playing
            playbackTimerId = setInterval(() => {
                if (currentPlayState) {
                    // Only increment if currently playing
                    currentProgressMs += 1000; // Add 1 second

                    // Update UI
                    progressBar.value = currentProgressMs;
                    currentTimeDisplay.textContent = formatTime(currentProgressMs);
                }
            }, 1000);
        }

        // Set up Spotify functionality
        function setupSpotify(token) {
            // Set up event listeners for progress bar
            progressBar.addEventListener('input', () => {
                // Optional: Could provide visual feedback while dragging
            });

            progressBar.addEventListener('change', () => {
                const newPosition = parseInt(progressBar.value);
                spotifyApiCall('PUT', `/me/player/seek?position_ms=${newPosition}`);
                setTimeout(getCurrentlyPlaying, 250); // Quicker update after seek
            });

            // Start polling for current track
            getCurrentlyPlaying();
            
            // Start separate timer for updating playback position
            startPlaybackTimer();
            
            // Adaptive polling
            let pollingInterval = 2000;
            const maxPollingInterval = 10000;
            let inactiveTime = 0;

            function adaptivePolling() {
                getCurrentlyPlaying()
                    .then(hasActivity => {
                        if (hasActivity) {
                            inactiveTime = 0;
                            pollingInterval = 2000;
                        } else {
                            inactiveTime += pollingInterval;
                            if (inactiveTime > 30000) {
                                pollingInterval = Math.min(pollingInterval * 1.5, maxPollingInterval);
                            }
                        }
                        setTimeout(adaptivePolling, pollingInterval);
                    });
            }

            adaptivePolling();
        }

        // Make API calls to Spotify
        async function spotifyApiCall(method, endpoint, body = null) {
            const token = localStorage.getItem('spotify_access_token');
            let retryCount = 0;
            const maxRetries = 2;

            while (retryCount <= maxRetries) {
                try {
                    const response = await fetch(`${SPOTIFY_API_ENDPOINT}${endpoint}`, {
                        method: method,
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: body ? JSON.stringify(body) : null
                    });

                    if (response.status === 401) {
                        try {
                            await refreshAccessToken();
                            retryCount++;
                            continue;
                        } catch (refreshError) {
                            console.error('Token refresh failed:', refreshError);
                            localStorage.removeItem('spotify_access_token');
                            localStorage.removeItem('spotify_refresh_token');
                            alert('Your session has expired. Please log in again.');
                            window.location.reload();
                            return null;
                        }
                    }

                    if (response.status === 204) {
                        return true;
                    }

                    if (response.ok) {
                        if (response.status !== 204) {
                            const text = await response.text();
                            if (!text) return null;

                            try {
                                if (text.trim().startsWith('{') || text.trim().startsWith('[')) {
                                    return JSON.parse(text);
                                } else {
                                    console.log('Non-JSON response:', text);
                                    return null;
                                }
                            } catch (parseError) {
                                console.error('JSON Parse Error:', parseError);
                                console.log('Response text:', text);
                                return null;
                            }
                        }
                        return true;
                    } else if (response.status === 429) {
                        const retryAfter = response.headers.get('Retry-After') || 5;
                        console.log(`Rate limited, waiting ${retryAfter} seconds...`);
                        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
                        retryCount++;
                        continue;
                    } else {
                        console.error('API Error:', response.status);
                        return null;
                    }
                } catch (error) {
                    console.error('API Request Failed:', error);
                    if (retryCount < maxRetries) {
                        const waitTime = Math.pow(2, retryCount) * 1000;
                        console.log(`Retrying in ${waitTime / 1000} seconds...`);
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        retryCount++;
                        continue;
                    }
                    return null;
                }
            }
            return null;
        }

        // Get and display currently playing track
        async function getCurrentlyPlaying() {
            try {
                const data = await spotifyApiCall('GET', '/me/player/currently-playing');
                let activityDetectedForPolling = false;

                if (data && data.item) {
                    const newTrackId = data.item.id;
                    const newAlbumId = data.item.album ? data.item.album.id : null;
                    const newPlayState = data.is_playing;
                    const newProgress = typeof data.progress_ms !== 'undefined' ? data.progress_ms : currentProgressMs;

                    const trackChanged = currentTrackId !== newTrackId;
                    const albumChanged = newAlbumId !== currentAlbumId;
                    const playStateChanged = currentPlayState !== newPlayState;
                    const progressChanged = currentProgressMs !== newProgress;

                    if (trackChanged) {
                        trackName.textContent = data.item.name;
                        artistName.textContent = data.item.artists.map(artist => artist.name).join(', ');
                        albumName.textContent = data.item.album ? data.item.album.name : '';
                        currentTrackId = newTrackId;
                        activityDetectedForPolling = true;

                        // Fetch artist image when track changes
                        if (data.item.artists && data.item.artists.length > 0) {
                            const artistId = data.item.artists[0].id;
                            fetchArtistImage(artistId);
                        } else {
                            updateBackground();
                        }
                    }

                    if (playStateChanged || trackChanged) {
                        currentPlayState = newPlayState;
                        // Update progress bar class based on play state
                        updateProgressBarState(newPlayState);
                        // Restart the playback timer when play state changes
                        startPlaybackTimer();
                        activityDetectedForPolling = true;
                    }

                    if (progressChanged || trackChanged) {
                        if (data.item.duration_ms) {
                            progressBar.max = data.item.duration_ms;
                            totalTimeDisplay.textContent = formatTime(data.item.duration_ms);
                        }
                        progressBar.value = newProgress;
                        currentTimeDisplay.textContent = formatTime(newProgress);
                        currentProgressMs = newProgress;
                        if (progressChanged && !trackChanged && !playStateChanged) activityDetectedForPolling = true;
                    }

                    if (newAlbumId && (albumChanged || !albumArt.hasChildNodes())) {
                        currentAlbumId = newAlbumId;
                        const albumArtCacheKey = `spotify_album_art_${newAlbumId}`;
                        let cachedArtUrl = localStorage.getItem(albumArtCacheKey);

                        if (cachedArtUrl) {
                            const img = new Image();
                            img.onload = () => {
                                albumArt.innerHTML = `<img src="${cachedArtUrl}" alt="Album Art" style="width:100%; height:100%; border-radius:8px;">`;
                            };
                            img.onerror = () => {
                                localStorage.removeItem(albumArtCacheKey);
                                if (data.item.album) {
                                    fetchAndSetAlbumArt(data.item.album, newAlbumId);
                                } else {
                                    albumArt.innerHTML = '';
                                }
                            };
                            img.src = cachedArtUrl;
                        } else if (data.item.album && data.item.album.images && data.item.album.images.length > 0) {
                            fetchAndSetAlbumArt(data.item.album, newAlbumId);
                        } else {
                            albumArt.innerHTML = '';
                        }
                        activityDetectedForPolling = true;
                    }
                    return activityDetectedForPolling;
                } else if (currentTrackId !== null) {
                    currentTrackId = null;
                    currentPlayState = null;
                    currentAlbumId = null;
                    currentProgressMs = 0;
                    trackName.textContent = 'Not Playing';
                    artistName.textContent = '-';
                    albumName.textContent = '';
                    albumArt.innerHTML = '';
                    progressBar.value = 0;
                    progressBar.max = 0;
                    currentTimeDisplay.textContent = '0:00';
                    totalTimeDisplay.textContent = '0:00';

                    // Update progress bar class for not playing state
                    updateProgressBarState(null);

                    // Clear the playback timer when playback stops
                    if (playbackTimerId) {
                        clearInterval(playbackTimerId);
                        playbackTimerId = null;
                    }

                    document.body.style.setProperty('--album-bg', 'none');
                    return true;
                }

                return activityDetectedForPolling;
            } catch (error) {
                console.error('Error updating player:', error);
                return false;
            }
        }

        // Fetch artist image and use it for background
        async function fetchArtistImage(artistId) {
            if (isUpdatingBackground) return;
            isUpdatingBackground = true;

            try {
                if (!artistId) {
                    await updateBackground();
                    return;
                }

                const artistImageCacheKey = `spotify_artist_image_${artistId}`;
                const cachedArtistImageUrl = localStorage.getItem(artistImageCacheKey);

                if (cachedArtistImageUrl) {
                    if (currentBackgroundUrl !== cachedArtistImageUrl) {
                        await setBackgroundImage(cachedArtistImageUrl);
                        currentBackgroundUrl = cachedArtistImageUrl;
                    }
                    return;
                }

                const artistData = await spotifyApiCall('GET', `/artists/${artistId}`);
                if (artistData && artistData.images && artistData.images.length > 0) {
                    const artistImageUrl = artistData.images[0].url;
                    if (currentBackgroundUrl !== artistImageUrl) {
                        try {
                            localStorage.setItem(artistImageCacheKey, artistImageUrl);
                        } catch (e) {
                            console.warn("Could not cache artist image, localStorage might be full.", e);
                        }
                        await setBackgroundImage(artistImageUrl);
                        currentBackgroundUrl = artistImageUrl;
                    }
                } else {
                    await updateBackground();
                }
            } catch (error) {
                console.error("Error fetching artist image:", error);
                await updateBackground();
            } finally {
                isUpdatingBackground = false;
            }
        }

        // Helper function to preload an image
        function preloadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve();
                img.onerror = () => reject(new Error(`Failed to load image: ${url}`));
                img.src = url;
            });
        }

        // Helper function to set background image with transition
        async function setBackgroundImage(imageUrl) {
            await preloadImage(imageUrl);
            
            document.body.style.setProperty('--album-bg-next', `url("${imageUrl}")`);

            await new Promise(resolve => setTimeout(resolve, 50));

            document.body.style.setProperty('--bg-opacity', '0');

            await new Promise(resolve => setTimeout(resolve, 100));

            document.body.style.setProperty('--album-bg', `url("${imageUrl}")`);
            document.body.style.setProperty('--album-bg-next', 'none');
            document.body.style.setProperty('--bg-opacity', '1');
        }

        // Helper function to update the background with current album art
        async function updateBackground() {
            if (!currentAlbumId) return;

            try {
                const albumArtCacheKey = `spotify_album_art_${currentAlbumId}`;
                const cachedArtUrl = localStorage.getItem(albumArtCacheKey);

                if (cachedArtUrl && currentBackgroundUrl !== cachedArtUrl) {
                    await setBackgroundImage(cachedArtUrl);
                    currentBackgroundUrl = cachedArtUrl;
                }
            } catch (error) {
                console.error("Error updating background:", error);
            }
        }

        // Helper function to fetch, display, and cache album art
        async function fetchAndSetAlbumArt(albumData, albumId) {
            if (albumData && albumData.images && albumData.images.length > 0) {
                const imageUrl = albumData.images[0].url;
                const albumArtCacheKey = `spotify_album_art_${albumId}`;

                const img = new Image();
                img.onload = async () => {
                    albumArt.innerHTML = `<img src="${imageUrl}" alt="Album Art" style="width:100%; height:100%; border-radius:8px;">`;
                    try {
                        localStorage.setItem(albumArtCacheKey, imageUrl);
                    } catch (e) {
                        console.warn("Could not cache album art, localStorage might be full.", e);
                    }
                };
                img.onerror = () => {
                    console.error("Failed to load album art image:", imageUrl);
                    albumArt.innerHTML = '';
                };
                img.src = imageUrl;
            } else {
                albumArt.innerHTML = '';
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>

</html>