<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Controller</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root {
            /* Base icon sizes */
            --icon-size-xs: 16px;
            --icon-size-sm: 20px;
            --icon-size-md: 24px;
            --icon-size-lg: 36px;
            --icon-size-xl: 48px;
            --icon-size-xxl: 80px;
            
            /* Icon size assignments */
            --play-pause-icon-size: var(--icon-size-xxl);
            --prev-next-icon-size: var(--icon-size-xl);
            --utility-icon-size: var(--icon-size-md);
            
            /* Button padding (determines size based on content) */
            --btn-control-padding: 16px;
            --btn-border-radius: 30px;
            --btn-play-border-radius: 50%;
            
            /* Button colors */
            --color-spotify-green: #1db9542a;
            --color-spotify-green-hover: #1ed75f25;
            --color-playing-blue: #1a73e81d;
            --color-button-bg: #1ed75f25;
            --color-button-utility: rgba(40, 40, 40, 0.7);
            
            /* Spacing */
            --spacing-xs: 8px;
            --spacing-sm: 10px;
            --spacing-md: 20px;
            --spacing-lg: 30px;
        }
        
        @media (max-width: 768px) {
            :root {
                /* Smaller sizes for mobile */
                --btn-play-pause-size: 70px;
                --btn-control-size: 46px;
                --btn-utility-size: 40px;
                --spacing-lg: 24px;
                --spacing-md: 16px;
            }
        }
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background-color: #000000;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #login-container {
            text-align: center;
            padding: 20px;
            max-width: 90%;
        }
        #player-container {
            display: none;
            width: 100%;
            max-width: 800px;
            text-align: center;
            padding: 20px;
            position: relative; /* For absolute positioning of children */
        }
        /* Fullscreen styling */
        #player-container:fullscreen {
            background-color: #121212;
            max-width: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 20px;
        }
        #player-container:fullscreen #album-art {
            margin: 15px auto;
        }
        #player-container:fullscreen .album-info-container {
            flex-direction: column;
            align-items: center;
        }
        #player-container:fullscreen #track-info {
            margin-left: 0;
            text-align: center;
            margin-top: 15px;
        }
        
        #player-container:fullscreen #prev-button {
            left: 5%;
        }
        
        #player-container:fullscreen #next-button {
            right: 5%;
        }
        .hidden {
            display: none !important;
        }
        button {
            background-color: var(--color-button-bg);
            color: white;
            border: none;
            padding: var(--btn-control-padding); /* Bigger buttons */
            border-radius: var(--btn-border-radius);
            font-weight: bold;
            cursor: pointer;
            margin: var(--spacing-sm);
            font-size: 20px; /* Larger font for buttons */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        button:hover, button:active {
            background-color: #1ed75f25;
            transform: scale(1.05);
        }
        .album-info-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }
        #album-art {
            width: 300px;
            height: 300px;
            box-shadow: 0 8px 60px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            flex-shrink: 0;
        }
        #track-info {
            margin-left: 30px;
            text-align: left;
            flex-grow: 1;
            max-width: 400px;
        }
        #track-name {
            font-size: 28px;
            margin-bottom: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #artist-name {
            font-size: 20px;
            color: #b3b3b3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #progress-container {
            margin: 55px auto;
            width: 90%;
            max-width: 800px;
        }
        #progress-bar {
            width: 100%;
            cursor: pointer;
            height: 10px;
            -webkit-appearance: none;
            appearance: none;
            background: #535353;
            border-radius: 5px;
            outline: none;
        }
        #progress-bar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #1DB954;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        #time-display {
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            color: #9AA0A6; /* Modern gray for time display */
            margin-top: 8px;
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        
        #prev-button {
            position: fixed;
            left: 5%;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
        }
        
        #next-button {
            position: fixed;
            right: 5%;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
        }
        
        @media (max-width: 768px) {
            #prev-button {
                left: 10px;
            }
            
            #next-button {
                right: 10px;
            }
        }
        .control-button {
            padding: var(--btn-control-padding);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: var(--spacing-md);
            /* Remove width/height, let padding determine size */
        }
        #play-pause-button {
            background-color: #1db9543a;
            padding: var(--btn-control-padding);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 var(--spacing-lg);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            /* Remove width/height, let content and padding determine size */
        }
        #play-pause-button:hover, #play-pause-button:active {
            transform: scale(1.1);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }
        #mute-toggle-button, #fullscreen-button {
            position: fixed;
            background-color: rgba(40, 40, 40, 0.7);
            padding: var(--btn-control-padding);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            z-index: 1000;
            /* Remove width/height, let content and padding determine size */
        }
        
        #mute-toggle-button {
            bottom: var(--spacing-md);
            right: var(--spacing-md);
        }
        
        #fullscreen-button {
            top: var(--spacing-md);
            right: var(--spacing-md);
        }
        
        #mute-toggle-button:hover, #fullscreen-button:hover {
            background-color: rgba(60, 60, 60, 0.9);
        }
        .setup-instructions {
            background-color: #282828;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            max-width: 600px;
            text-align: left;
        }
        .setup-instructions code {
            background-color: #121212;
            padding: 2px 5px;
            border-radius: 3px;
        }
        @media (max-width: 768px) {
            :root {
                --unit: 7px; /* Slightly smaller base unit for mobile */
                /* All derived values will adjust automatically */
            }
            
            #album-art {
                width: 200px;
                height: 200px;
            }
            .album-info-container {
                flex-direction: column;
            }
            #track-info {
                margin-left: 0;
                margin-top: var(--spacing-lg);
                text-align: center;
            }
            button {
                font-size: var(--icon-size-sm);
            }
            #track-name {
                font-size: 24px;
            }
            #artist-name {
                font-size: 18px;
            }
        }
        /* Icon styling */
        .icon {
            font-family: 'Material Icons';
            font-weight: normal;
            font-style: normal;
            font-size: var(--icon-size-md); /* Default size */
            line-height: 1;
            letter-spacing: normal;
            text-transform: none;
            display: inline-block;
            white-space: nowrap;
            word-wrap: normal;
            direction: ltr;
            -webkit-font-smoothing: antialiased;
        }
        
        /* Control buttons icon sizes */
        #prev-button .icon {
            font-size: var(--prev-next-icon-size);
        }
        
        #play-pause-button .icon {
            font-size: var(--play-pause-icon-size);
        }
        
        #next-button .icon {
            font-size: var(--prev-next-icon-size);
        }
        
        /* Utility buttons icon sizes */
        #mute-toggle-button .icon {
            font-size: var(--utility-icon-size);
        }
        
        #fullscreen-button .icon {
            font-size: var(--utility-icon-size);
        }
        
        /* Play button states */
        #play-pause-button.playing {
            background-color: #1a73e81d; /* Modern blue when playing/pause button */
        }
        #play-pause-button.paused {
            background-color: #1db9542a; /* Original Spotify green when paused/play button */
        }
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Spotify Controller</h1>
            <div class="setup-instructions">
                <h2>First-time Setup:</h2>
                <ol>
                    <li>Create a Spotify Developer application at 
                    <a href="https://developer.spotify.com/dashboard" target="_blank">developer.spotify.com/dashboard</a></li>
                    <li>Set the Redirect URI to your current URL: <code id="redirect-uri">loading...</code>
                        <button id="copy-uri" style="padding: 2px 8px; margin-left: 5px;">Copy</button>
                    </li>
                    <li>Copy your Client ID</li>
                    <li>You can either:
                        <ul>
                            <li>Enter it below and click "Save Client ID", or</li>
                            <li>Append it to the URL like: <code id="url-example">loading...</code></li>
                        </ul>
                    </li>
                </ol>
            </div>
        <div>
            <input type="text" id="client-id-input" placeholder="Enter your Spotify Client ID">
            <button id="save-client-id">Save Client ID</button>
        </div>
        <button id="login-button" class="hidden">Connect to Spotify</button>
    </div>

    <div id="player-container">
        <div class="album-info-container">
            <div id="album-art"></div>
            <div id="track-info">
                <div id="track-name">Not Playing</div>
                <div id="artist-name">-</div>
            </div>
        </div>
        <div id="progress-container">
            <input type="range" id="progress-bar" value="0" style="width: 100%;">
            <div id="time-display">
                <span id="current-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
        </div>
        <div id="controls">
            <button id="next-button" class="control-button"><span class="icon">skip_next</span></button>
            <button id="play-pause-button" class="paused"><span class="icon">play_arrow</span></button>
            <button id="prev-button" class="control-button"><span class="icon">skip_previous</span></button>
        </div>
        <button id="mute-toggle-button"><span class="icon">volume_up</span></button>
        <button id="fullscreen-button"><span class="icon">fullscreen</span></button>
    </div>

    <script>
        // Authentication & Authorization
        const SPOTIFY_AUTH_ENDPOINT = 'https://accounts.spotify.com/authorize';
        const SPOTIFY_TOKEN_ENDPOINT = 'https://accounts.spotify.com/api/token';
        const SPOTIFY_API_ENDPOINT = 'https://api.spotify.com/v1';
        const SCOPES = [
            'user-read-private',
            'user-read-currently-playing',
            'user-read-playback-state',
            'user-modify-playback-state'
        ];
        
        // Generate a random string for the state parameter
        function generateRandomString(length) {
            let text = '';
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }
        
        // Generate a code verifier (random string between 43-128 chars)
        function generateCodeVerifier() {
            return generateRandomString(128);
        }
        
        // Generate code challenge from verifier using SHA-256
        async function generateCodeChallenge(codeVerifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(codeVerifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            
            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/=/g, '')
                .replace(/\+/g, '-')
                .replace(/\//g, '_');
        }
        
        // DOM Elements
const loginContainer = document.getElementById('login-container');
const playerContainer = document.getElementById('player-container');
const clientIdInput = document.getElementById('client-id-input');
const saveClientIdButton = document.getElementById('save-client-id');
const loginButton = document.getElementById('login-button');
const redirectUriElement = document.getElementById('redirect-uri');
const prevButton = document.getElementById('prev-button');
const playPauseButton = document.getElementById('play-pause-button');
const nextButton = document.getElementById('next-button');
const albumArt = document.getElementById('album-art');
const trackName = document.getElementById('track-name');
const artistName = document.getElementById('artist-name');
const progressBar = document.getElementById('progress-bar');
const currentTimeDisplay = document.getElementById('current-time');
const totalTimeDisplay = document.getElementById('total-time');
const muteToggleButton = document.getElementById('mute-toggle-button');
const fullscreenButton = document.getElementById('fullscreen-button');

// Get the base URL for redirect URI
const baseUrl = window.location.origin + window.location.pathname;

// Set the redirect URI text and URL example
redirectUriElement.textContent = baseUrl;
const urlExample = document.getElementById('url-example');
urlExample.textContent = baseUrl + '#client_id=YOUR_CLIENT_ID';
        
        // Check URL hash for client ID first
        let clientId;
        const urlParams = new URLSearchParams(window.location.hash.substring(1));
        const urlClientId = urlParams.get('client_id');
        
        if (urlClientId) {
            // Found client ID in URL, save it to localStorage
            clientId = urlClientId;
            localStorage.setItem('spotify_client_id', clientId);
            // Remove hash from URL without page reload
            history.replaceState(null, null, window.location.pathname);
            clientIdInput.value = clientId;
            loginButton.classList.remove('hidden');
        } else {
            // Check localStorage as fallback
            clientId = localStorage.getItem('spotify_client_id');
            if (clientId) {
                clientIdInput.value = clientId;
                loginButton.classList.remove('hidden');
            }
        }
        
        // Save Client ID to localStorage
        saveClientIdButton.addEventListener('click', () => {
            const newClientId = clientIdInput.value.trim();
            if (newClientId) {
                localStorage.setItem('spotify_client_id', newClientId);
                clientId = newClientId;
                loginButton.classList.remove('hidden');
                alert('Client ID saved successfully!');
            } else {
                alert('Please enter a valid Client ID');
            }
        });
        
        // Handle Login
        loginButton.addEventListener('click', async () => {
            if (!clientId) {
                alert('Please enter your Spotify Client ID first');
                return;
            }
            
            // Generate and store PKCE code verifier
            const codeVerifier = generateCodeVerifier();
            localStorage.setItem('spotify_code_verifier', codeVerifier);
            
            // Generate code challenge from verifier
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            
            // Generate state parameter
            const state = generateRandomString(16);
            localStorage.setItem('spotify_auth_state', state);
            
            const authUrl = new URL(SPOTIFY_AUTH_ENDPOINT);
            const params = {
                client_id: clientId,
                redirect_uri: baseUrl,
                scope: SCOPES.join(' '),
                response_type: 'code',
                code_challenge_method: 'S256',
                code_challenge: codeChallenge,
                state: state,
                show_dialog: true
            };
            
            authUrl.search = new URLSearchParams(params).toString();
            window.location.href = authUrl.toString();
        });
        
        // Parse query parameters from URL
        function getQueryParams() {
            const queryParams = {};
            const queryString = window.location.search.substring(1);
            
            if (!queryString) {
                return queryParams;
            }
            
            queryString.split('&').forEach(pair => {
                const [key, value] = pair.split('=');
                queryParams[key] = decodeURIComponent(value);
            });
            
            return queryParams;
        }
        
        // Exchange authorization code for an access token
        async function exchangeCodeForToken(code) {
            const clientId = localStorage.getItem('spotify_client_id');
            const codeVerifier = localStorage.getItem('spotify_code_verifier');
            
            if (!clientId || !codeVerifier) {
                throw new Error('Missing client ID or code verifier');
            }
            
            const params = new URLSearchParams();
            params.append('client_id', clientId);
            params.append('grant_type', 'authorization_code');
            params.append('code', code);
            params.append('redirect_uri', baseUrl);
            params.append('code_verifier', codeVerifier);
            
            const response = await fetch(SPOTIFY_TOKEN_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: params
            });
            
            if (!response.ok) {
                throw new Error(`Token request failed: ${response.status}`);
            }
            
            return await response.json();
        }
        
        // Initialize app
        async function initApp() {
            // Check if we have a code in the URL (redirect from Spotify auth)
            const queryParams = getQueryParams();
            const code = queryParams.code;
            const state = queryParams.state;
            const error = queryParams.error;
            
            // Check for errors
            if (error) {
                console.error(`Authorization error: ${error}`);
                alert(`Authorization failed: ${error}`);
                return;
            }
            
            // Check for authorization code
            if (code) {
                try {
            // Remove the code from the URL without changing the base URL
            const currentUrl = new URL(window.location.href);
            currentUrl.searchParams.delete('code');
            currentUrl.searchParams.delete('state');
            window.history.replaceState({}, document.title, currentUrl.toString());
                    
                    // Verify state parameter
                    const storedState = localStorage.getItem('spotify_auth_state');
                    if (state !== storedState) {
                        throw new Error('State mismatch, possible CSRF attack');
                    }
                    
                    // Exchange the code for an access token
                    const data = await exchangeCodeForToken(code);
                    
                    // Store token and expiration
                    const accessToken = data.access_token;
                    const refreshToken = data.refresh_token;
                    const expiresIn = data.expires_in;
                    const tokenTimestamp = Date.now();
                    
                    localStorage.setItem('spotify_access_token', accessToken);
                    localStorage.setItem('spotify_refresh_token', refreshToken);
                    localStorage.setItem('spotify_token_timestamp', tokenTimestamp);
                    localStorage.setItem('spotify_token_expires_in', expiresIn);
                    
                    // Show player UI
                    loginContainer.style.display = 'none';
                    playerContainer.style.display = 'block';
                    
                    // Set up player
                    setupPlayer(accessToken);
                    return;
                } catch (error) {
                    console.error('Error exchanging code for token:', error);
                    alert(`Authentication error: ${error.message}`);
                }
            }
            
            // If no code in URL, check if we have a valid stored token
            const storedToken = localStorage.getItem('spotify_access_token');
            const storedTimestamp = localStorage.getItem('spotify_token_timestamp');
            const storedExpiresIn = localStorage.getItem('spotify_token_expires_in');
            
            if (storedToken && storedTimestamp && storedExpiresIn) {
                const now = Date.now();
                const elapsed = (now - storedTimestamp) / 1000;
                
                if (elapsed < storedExpiresIn) {
                    // Token still valid
                    loginContainer.style.display = 'none';
                    playerContainer.style.display = 'block';
                    
                    // Set up player
                    setupPlayer(storedToken);
                    return;
                } else {
                    // Token expired, try to refresh it
                    try {
                        await refreshAccessToken();
                        
                        // If refresh successful, set up player
                        loginContainer.style.display = 'none';
                        playerContainer.style.display = 'block';
                        
                        setupPlayer(localStorage.getItem('spotify_access_token'));
                        return;
                    } catch (error) {
                        console.error('Error refreshing token:', error);
                        // If refresh fails, we'll continue to show login screen
                    }
                }
            }
            
            // If we reach here, we need to login again
            loginContainer.style.display = 'block';
            playerContainer.style.display = 'none';
        }
        
        // Refresh the access token using the refresh token
        async function refreshAccessToken() {
            const clientId = localStorage.getItem('spotify_client_id');
            const refreshToken = localStorage.getItem('spotify_refresh_token');
            
            if (!clientId || !refreshToken) {
                throw new Error('Missing client ID or refresh token');
            }
            
            const params = new URLSearchParams();
            params.append('client_id', clientId);
            params.append('grant_type', 'refresh_token');
            params.append('refresh_token', refreshToken);
            
            const response = await fetch(SPOTIFY_TOKEN_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: params
            });
            
            if (!response.ok) {
                throw new Error(`Refresh token request failed: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Update stored tokens
            localStorage.setItem('spotify_access_token', data.access_token);
            localStorage.setItem('spotify_token_timestamp', Date.now());
            localStorage.setItem('spotify_token_expires_in', data.expires_in);
            
            // If a new refresh token is provided, update it
            if (data.refresh_token) {
                localStorage.setItem('spotify_refresh_token', data.refresh_token);
            }
            
            return data;
        }
        
        // Format time from ms to M:SS
        function formatTime(ms) {
            if (isNaN(ms) || ms < 0) return "0:00";
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        // Global state for volume
        let currentVolumeBeforeMute = 50; // Default volume to restore to if unmuting from 0
        let isCurrentlyMuted = false;

        // Track state to avoid unnecessary UI updates
        let currentTrackId = null;
        let currentPlayState = null;
        let currentAlbumId = null; // Added to track current album for art caching
        let currentProgressMs = 0; // To track progress for polling activity

        // Set up player functionality
        function setupPlayer(token) {
            // Set up event listeners for player controls
            prevButton.addEventListener('click', () => {
                spotifyApiCall('POST', '/me/player/previous');
                setTimeout(getCurrentlyPlaying, 500);
            });
            
            playPauseButton.addEventListener('click', () => {
                if (currentPlayState) {
                    // If currently playing, pause
                    spotifyApiCall('PUT', '/me/player/pause');
                    playPauseButton.querySelector('.icon').textContent = 'play_arrow';
                    playPauseButton.classList.remove('playing');
                    playPauseButton.classList.add('paused');
                } else {
                    // If paused or stopped, play
                    spotifyApiCall('PUT', '/me/player/play');
                    playPauseButton.querySelector('.icon').textContent = 'pause';
                    playPauseButton.classList.remove('paused');
                    playPauseButton.classList.add('playing');
                }
                setTimeout(getCurrentlyPlaying, 500);
            });
            
            nextButton.addEventListener('click', () => {
                spotifyApiCall('POST', '/me/player/next');
                setTimeout(getCurrentlyPlaying, 500);
            });
            
            progressBar.addEventListener('input', () => {
                // Optional: Could provide visual feedback while dragging
                // For now, we only seek when the user releases (change event)
            });

            progressBar.addEventListener('change', () => {
                const newPosition = parseInt(progressBar.value);
                spotifyApiCall('PUT', `/me/player/seek?position_ms=${newPosition}`);
                // Update UI optimistically or wait for polling
                setTimeout(getCurrentlyPlaying, 250); // Quicker update after seek
            });
            
            muteToggleButton.addEventListener('click', async () => {
                let targetVolume;
                if (isCurrentlyMuted) {
                    targetVolume = currentVolumeBeforeMute > 0 ? currentVolumeBeforeMute : 50; // Restore or default
                    muteToggleButton.querySelector('.icon').textContent = 'volume_up'; // Immediately update UI
                    isCurrentlyMuted = false; // Immediately update state
                } else {
                    // Before muting, store current volume
                    const playerData = await spotifyApiCall('GET', '/me/player');
                    if (playerData && playerData.device && typeof playerData.device.volume_percent !== 'undefined') {
                        currentVolumeBeforeMute = playerData.device.volume_percent;
                    }
                    targetVolume = 0;
                    muteToggleButton.querySelector('.icon').textContent = 'volume_off'; // Immediately update UI
                    isCurrentlyMuted = true; // Immediately update state
                }
                await spotifyApiCall('PUT', `/me/player/volume?volume_percent=${targetVolume}`);
                setTimeout(getCurrentlyPlaying, 250); // Refresh state from API
            });
            
            // Fullscreen toggle functionality
            fullscreenButton.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    if (playerContainer.requestFullscreen) {
                        playerContainer.requestFullscreen();
                    } else if (playerContainer.webkitRequestFullscreen) { /* Safari */
                        playerContainer.webkitRequestFullscreen();
                    } else if (playerContainer.msRequestFullscreen) { /* IE11 */
                        playerContainer.msRequestFullscreen();
                    }
                    fullscreenButton.querySelector('.icon').textContent = 'fullscreen_exit';
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) { /* Safari */
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE11 */
                        document.msExitFullscreen();
                    }
                    fullscreenButton.querySelector('.icon').textContent = 'fullscreen';
                }
            });
            
            // Listen for fullscreen change events (like when user presses Escape)
            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement) {
                    fullscreenButton.querySelector('.icon').textContent = 'fullscreen';
                } else {
                    fullscreenButton.querySelector('.icon').textContent = 'fullscreen_exit';
                }
            });
            
            // Start polling for current track
            getCurrentlyPlaying();
            
            // Adaptive polling - increase interval when inactive
            let pollingInterval = 5000; // Start with 5 seconds
            const maxPollingInterval = 15000; // Max 15 seconds between polls
            let inactiveTime = 0;
            
            function adaptivePolling() {
                getCurrentlyPlaying()
                    .then(hasActivity => {
                        // If track changed or playback state changed
                        if (hasActivity) {
                            inactiveTime = 0;
                            pollingInterval = 5000; // Reset to 5 seconds
                        } else {
                            inactiveTime += pollingInterval;
                            // Gradually increase polling interval when inactive
                            if (inactiveTime > 30000) { // After 30 seconds of inactivity
                                pollingInterval = Math.min(pollingInterval * 1.5, maxPollingInterval);
                            }
                        }
                        // Schedule next check
                        setTimeout(adaptivePolling, pollingInterval);
                    });
            }
            
            // Start adaptive polling
            adaptivePolling();
            
            // Start separate timer for updating playback position
            startPlaybackTimer();
        }
        
        // Timer for updating the playback position without API calls
        let playbackTimerId = null;
        
        function startPlaybackTimer() {
            // Clear any existing timer
            if (playbackTimerId) {
                clearInterval(playbackTimerId);
            }
            
            // Update playback position every second if music is playing
            playbackTimerId = setInterval(() => {
                if (currentPlayState) {
                    // Only increment if currently playing
                    currentProgressMs += 1000; // Add 1 second
                    
                    // Update UI
                    progressBar.value = currentProgressMs;
                    currentTimeDisplay.textContent = formatTime(currentProgressMs);
                }
            }, 1000);
        }
        
        // Make API calls to Spotify
        async function spotifyApiCall(method, endpoint, body = null) {
            const token = localStorage.getItem('spotify_access_token');
            
            try {
                const response = await fetch(`${SPOTIFY_API_ENDPOINT}${endpoint}`, {
                    method: method,
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: body ? JSON.stringify(body) : null
                });
                
                if (response.status === 401) {
                    // Token expired
                    localStorage.removeItem('spotify_access_token');
                    alert('Your session has expired. Please log in again.');
                    window.location.reload();
                    return null;
                }
                
                if (response.status === 204) {
                    return true; // Success but no content
                }
                
                if (response.ok) {
                    // Only try to parse as JSON if there's content
                    if (response.status !== 204) {
                        const text = await response.text();
                        // Check if there's any content to parse
                        if (!text) return null;
                        
                        try {
                            // Check if the response starts with a valid JSON character
                            if (text.trim().startsWith('{') || text.trim().startsWith('[')) {
                                return JSON.parse(text);
                            } else {
                                console.log('Non-JSON response:', text);
                                return null;
                            }
                        } catch (parseError) {
                            console.error('JSON Parse Error:', parseError);
                            console.log('Response text:', text);
                            return null;
                        }
                    }
                    return true;
                } else {
                    console.error('API Error:', response.status);
                    return null;
                }
            } catch (error) {
                console.error('API Request Failed:', error);
                return null;
            }
        }
        
        // Get and display currently playing track
        async function getCurrentlyPlaying() {
            try {
                const data = await spotifyApiCall('GET', '/me/player/currently-playing');
                let activityDetectedForPolling = false;

                if (data) { // If data is not null (API call returned something)
                    // Always update mute button state if device info is available
                    if (data.device && typeof data.device.volume_percent !== 'undefined') {
                        const previousMuteState = isCurrentlyMuted;
                        const actualVolume = data.device.volume_percent;

                        if (actualVolume === 0) {
                            isCurrentlyMuted = true;
                            muteToggleButton.querySelector('.icon').textContent = 'volume_off';
                            // currentVolumeBeforeMute retains its value from when it was last non-zero
                        } else {
                            isCurrentlyMuted = false;
                            muteToggleButton.querySelector('.icon').textContent = 'volume_up';
                            currentVolumeBeforeMute = actualVolume; // Store the current non-zero volume
                        }
                        if (isCurrentlyMuted !== previousMuteState) {
                            activityDetectedForPolling = true; // Mute state change is an activity
                        }
                    } else {
                        // console.log("Device or volume info missing in getCurrentlyPlaying response.");
                        // Potentially disable mute button or leave its state as is if no device info
                    }

                    // Handle track-specific information
                    if (data.item) {
                        const newTrackId = data.item.id;
                        const newAlbumId = data.item.album ? data.item.album.id : null;
                        const newPlayState = data.is_playing;
                        const newProgress = typeof data.progress_ms !== 'undefined' ? data.progress_ms : currentProgressMs;

                        const trackChanged = currentTrackId !== newTrackId;
                        const playStateChanged = currentPlayState !== newPlayState;
                        const albumChanged = newAlbumId !== currentAlbumId;
                        const progressChanged = currentProgressMs !== newProgress;

                        // Update play/pause button icon based on play state
                        if (newPlayState !== currentPlayState) {
                            playPauseButton.querySelector('.icon').textContent = newPlayState ? 'pause' : 'play_arrow';
                            if (newPlayState) {
                                playPauseButton.classList.remove('paused');
                                playPauseButton.classList.add('playing');
                            } else {
                                playPauseButton.classList.remove('playing');
                                playPauseButton.classList.add('paused');
                            }
                            
                            // Restart the playback timer when play state changes
                            startPlaybackTimer();
                        }

                        if (trackChanged || playStateChanged) {
                            trackName.textContent = data.item.name;
                            artistName.textContent = data.item.artists.map(artist => artist.name).join(', ');
                            currentTrackId = newTrackId;
                            currentPlayState = newPlayState;
                            activityDetectedForPolling = true;
                            
                            // Reset the playback timer on track change
                            if (trackChanged) {
                                startPlaybackTimer();
                            }
                        }
                        
                        if (progressChanged || trackChanged) { // Update progress if it changed or track changed
                             if (data.item.duration_ms) {
                                progressBar.max = data.item.duration_ms;
                                totalTimeDisplay.textContent = formatTime(data.item.duration_ms);
                            }
                            progressBar.value = newProgress;
                            currentTimeDisplay.textContent = formatTime(newProgress);
                            currentProgressMs = newProgress;
                            if(progressChanged && !trackChanged && !playStateChanged) activityDetectedForPolling = true; // if only progress changed
                        }

                        if (newAlbumId && (albumChanged || !albumArt.hasChildNodes())) {
                            currentAlbumId = newAlbumId;
                            const albumArtCacheKey = `spotify_album_art_${newAlbumId}`;
                            let cachedArtUrl = localStorage.getItem(albumArtCacheKey);

                            if (cachedArtUrl) {
                                const img = new Image();
                                img.onload = () => {
                                    albumArt.innerHTML = `<img src="${cachedArtUrl}" alt="Album Art" style="width:100%; height:100%; border-radius:8px;">`;
                                };
                                img.onerror = () => {
                                    localStorage.removeItem(albumArtCacheKey);
                                    if (data.item.album) {
                                       fetchAndSetAlbumArt(data.item.album, newAlbumId);
                                    } else {
                                       albumArt.innerHTML = '';
                                    }
                                };
                                img.src = cachedArtUrl;
                            } else if (data.item.album && data.item.album.images && data.item.album.images.length > 0) {
                                fetchAndSetAlbumArt(data.item.album, newAlbumId);
                            } else {
                                albumArt.innerHTML = '';
                            }
                            activityDetectedForPolling = true;
                        }
                        return activityDetectedForPolling;
                    } else if (currentTrackId !== null) { // Music stopped (no item, but was playing before)
                        currentTrackId = null;
                        currentPlayState = null;
                        currentAlbumId = null;
                        currentProgressMs = 0;
                        trackName.textContent = 'Not Playing';
                        artistName.textContent = '-';
                        albumArt.innerHTML = '';
                        progressBar.value = 0;
                        progressBar.max = 0;
                        currentTimeDisplay.textContent = '0:00';
                        totalTimeDisplay.textContent = '0:00';
                        
                        // Clear the playback timer when playback stops
                        if (playbackTimerId) {
                            clearInterval(playbackTimerId);
                            playbackTimerId = null;
                        }
                        
                        return true; // Activity detected - state changed to not playing
                    }
                } else if (data === null && currentTrackId !== null ) { // API call failed, but we thought it was playing
                     // If API call fails (data is null), and we thought a track was playing, treat as state change.
                    currentTrackId = null; // Reset to trigger login/refresh if needed by other logic
                    return true; // Indicate activity to potentially slow down polling or re-check auth
                }
                
                return activityDetectedForPolling; // Return if any activity (mute, track, playstate, album, progress) was detected
            } catch (error) {
                console.error('Error updating player:', error);
                return false; // No activity on error
            }
        }
        
        // Helper function to fetch, display, and cache album art
        function fetchAndSetAlbumArt(albumData, albumId) {
            if (albumData && albumData.images && albumData.images.length > 0) {
                const imageUrl = albumData.images[0].url;
                const albumArtCacheKey = `spotify_album_art_${albumId}`;

                const img = new Image();
                img.onload = () => {
                    albumArt.innerHTML = `<img src="${imageUrl}" alt="Album Art" style="width:100%; height:100%; border-radius:8px;">`;
                    try {
                        localStorage.setItem(albumArtCacheKey, imageUrl);
                    } catch (e) {
                        console.warn("Could not cache album art, localStorage might be full.", e);
                    }
                };
                img.onerror = () => {
                    console.error("Failed to load album art image:", imageUrl);
                    albumArt.innerHTML = ''; // Clear art on error
                };
                img.src = imageUrl;
            } else {
                albumArt.innerHTML = ''; // No art available for this album
            }
        }
        
        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
