<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Controller</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #121212;
            color: white;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #login-container {
            text-align: center;
            padding: 20px;
        }
        #player-container {
            display: none;
            width: 100%;
            max-width: 800px;
            text-align: center;
        }
        .hidden {
            display: none !important;
        }
        button {
            background-color: #1DB954;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #1ed760;
        }
        #album-art {
            width: 300px;
            height: 300px;
            margin: 20px auto;
            box-shadow: 0 4px 60px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
        }
        #track-info {
            margin-bottom: 20px;
        }
        #track-name {
            font-size: 24px;
            margin-bottom: 5px;
        }
        #artist-name {
            font-size: 18px;
            color: #b3b3b3;
        }
        #progress-container {
            margin: 15px auto;
            width: 80%;
            max-width: 400px;
        }
        #progress-bar {
            width: 100%;
            cursor: pointer;
        }
        #time-display {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #b3b3b3;
            margin-top: 5px;
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }
        .setup-instructions {
            background-color: #282828;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            max-width: 600px;
            text-align: left;
        }
        .setup-instructions code {
            background-color: #121212;
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div id="login-container">
        <h1>Spotify Controller</h1>
            <div class="setup-instructions">
                <h2>First-time Setup:</h2>
                <ol>
                    <li>Create a Spotify Developer application at 
                    <a href="https://developer.spotify.com/dashboard" target="_blank">developer.spotify.com/dashboard</a></li>
                    <li>Set the Redirect URI to your current URL: <code id="redirect-uri">loading...</code>
                        <button id="copy-uri" style="padding: 2px 8px; margin-left: 5px;">Copy</button>
                    </li>
                    <li>Copy your Client ID</li>
                    <li>You can either:
                        <ul>
                            <li>Enter it below and click "Save Client ID", or</li>
                            <li>Append it to the URL like: <code id="url-example">loading...</code></li>
                        </ul>
                    </li>
                </ol>
            </div>
        <div>
            <input type="text" id="client-id-input" placeholder="Enter your Spotify Client ID">
            <button id="save-client-id">Save Client ID</button>
        </div>
        <button id="login-button" class="hidden">Connect to Spotify</button>
    </div>

    <div id="player-container">
        <div id="album-art"></div>
        <div id="track-info">
            <div id="track-name">Not Playing</div>
            <div id="artist-name">-</div>
        </div>
        <div id="progress-container">
            <input type="range" id="progress-bar" value="0" style="width: 100%;">
            <div id="time-display">
                <span id="current-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
        </div>
        <div id="controls">
            <button id="prev-button">Previous</button>
            <button id="play-button">Play</button>
            <button id="pause-button">Pause</button>
            <button id="next-button">Next</button>
            <button id="mute-toggle-button">Mute</button>
            <button id="fullscreen-button">Fullscreen</button>
        </div>
    </div>

    <script>
        // Authentication & Authorization
        const SPOTIFY_AUTH_ENDPOINT = 'https://accounts.spotify.com/authorize';
        const SPOTIFY_TOKEN_ENDPOINT = 'https://accounts.spotify.com/api/token';
        const SPOTIFY_API_ENDPOINT = 'https://api.spotify.com/v1';
        const SCOPES = [
            'user-read-private',
            'user-read-currently-playing',
            'user-read-playback-state',
            'user-modify-playback-state'
        ];
        
        // Generate a random string for the state parameter
        function generateRandomString(length) {
            let text = '';
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }
        
        // Generate a code verifier (random string between 43-128 chars)
        function generateCodeVerifier() {
            return generateRandomString(128);
        }
        
        // Generate code challenge from verifier using SHA-256
        async function generateCodeChallenge(codeVerifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(codeVerifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            
            return btoa(String.fromCharCode(...new Uint8Array(digest)))
                .replace(/=/g, '')
                .replace(/\+/g, '-')
                .replace(/\//g, '_');
        }
        
        // DOM Elements
const loginContainer = document.getElementById('login-container');
const playerContainer = document.getElementById('player-container');
const clientIdInput = document.getElementById('client-id-input');
const saveClientIdButton = document.getElementById('save-client-id');
const loginButton = document.getElementById('login-button');
const redirectUriElement = document.getElementById('redirect-uri');
const prevButton = document.getElementById('prev-button');
const playButton = document.getElementById('play-button');
const pauseButton = document.getElementById('pause-button');
const nextButton = document.getElementById('next-button');
const albumArt = document.getElementById('album-art');
const trackName = document.getElementById('track-name');
const artistName = document.getElementById('artist-name');
const progressBar = document.getElementById('progress-bar');
const currentTimeDisplay = document.getElementById('current-time');
const totalTimeDisplay = document.getElementById('total-time');
const muteToggleButton = document.getElementById('mute-toggle-button');
const fullscreenButton = document.getElementById('fullscreen-button');

// Get the base URL for redirect URI
const baseUrl = window.location.origin + window.location.pathname;

// Set the redirect URI text and URL example
redirectUriElement.textContent = baseUrl;
const urlExample = document.getElementById('url-example');
urlExample.textContent = baseUrl + '#client_id=YOUR_CLIENT_ID';
        
        // Check URL hash for client ID first
        let clientId;
        const urlParams = new URLSearchParams(window.location.hash.substring(1));
        const urlClientId = urlParams.get('client_id');
        
        if (urlClientId) {
            // Found client ID in URL, save it to localStorage
            clientId = urlClientId;
            localStorage.setItem('spotify_client_id', clientId);
            // Remove hash from URL without page reload
            history.replaceState(null, null, window.location.pathname);
            clientIdInput.value = clientId;
            loginButton.classList.remove('hidden');
        } else {
            // Check localStorage as fallback
            clientId = localStorage.getItem('spotify_client_id');
            if (clientId) {
                clientIdInput.value = clientId;
                loginButton.classList.remove('hidden');
            }
        }
        
        // Save Client ID to localStorage
        saveClientIdButton.addEventListener('click', () => {
            const newClientId = clientIdInput.value.trim();
            if (newClientId) {
                localStorage.setItem('spotify_client_id', newClientId);
                clientId = newClientId;
                loginButton.classList.remove('hidden');
                alert('Client ID saved successfully!');
            } else {
                alert('Please enter a valid Client ID');
            }
        });
        
        // Handle Login
        loginButton.addEventListener('click', async () => {
            if (!clientId) {
                alert('Please enter your Spotify Client ID first');
                return;
            }
            
            // Generate and store PKCE code verifier
            const codeVerifier = generateCodeVerifier();
            localStorage.setItem('spotify_code_verifier', codeVerifier);
            
            // Generate code challenge from verifier
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            
            // Generate state parameter
            const state = generateRandomString(16);
            localStorage.setItem('spotify_auth_state', state);
            
            const authUrl = new URL(SPOTIFY_AUTH_ENDPOINT);
            const params = {
                client_id: clientId,
                redirect_uri: baseUrl,
                scope: SCOPES.join(' '),
                response_type: 'code',
                code_challenge_method: 'S256',
                code_challenge: codeChallenge,
                state: state,
                show_dialog: true
            };
            
            authUrl.search = new URLSearchParams(params).toString();
            window.location.href = authUrl.toString();
        });
        
        // Parse query parameters from URL
        function getQueryParams() {
            const queryParams = {};
            const queryString = window.location.search.substring(1);
            
            if (!queryString) {
                return queryParams;
            }
            
            queryString.split('&').forEach(pair => {
                const [key, value] = pair.split('=');
                queryParams[key] = decodeURIComponent(value);
            });
            
            return queryParams;
        }
        
        // Exchange authorization code for an access token
        async function exchangeCodeForToken(code) {
            const clientId = localStorage.getItem('spotify_client_id');
            const codeVerifier = localStorage.getItem('spotify_code_verifier');
            
            if (!clientId || !codeVerifier) {
                throw new Error('Missing client ID or code verifier');
            }
            
            const params = new URLSearchParams();
            params.append('client_id', clientId);
            params.append('grant_type', 'authorization_code');
            params.append('code', code);
            params.append('redirect_uri', baseUrl);
            params.append('code_verifier', codeVerifier);
            
            const response = await fetch(SPOTIFY_TOKEN_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: params
            });
            
            if (!response.ok) {
                throw new Error(`Token request failed: ${response.status}`);
            }
            
            return await response.json();
        }
        
        // Initialize app
        async function initApp() {
            // Check if we have a code in the URL (redirect from Spotify auth)
            const queryParams = getQueryParams();
            const code = queryParams.code;
            const state = queryParams.state;
            const error = queryParams.error;
            
            // Check for errors
            if (error) {
                console.error(`Authorization error: ${error}`);
                alert(`Authorization failed: ${error}`);
                return;
            }
            
            // Check for authorization code
            if (code) {
                try {
            // Remove the code from the URL without changing the base URL
            const currentUrl = new URL(window.location.href);
            currentUrl.searchParams.delete('code');
            currentUrl.searchParams.delete('state');
            window.history.replaceState({}, document.title, currentUrl.toString());
                    
                    // Verify state parameter
                    const storedState = localStorage.getItem('spotify_auth_state');
                    if (state !== storedState) {
                        throw new Error('State mismatch, possible CSRF attack');
                    }
                    
                    // Exchange the code for an access token
                    const data = await exchangeCodeForToken(code);
                    
                    // Store token and expiration
                    const accessToken = data.access_token;
                    const refreshToken = data.refresh_token;
                    const expiresIn = data.expires_in;
                    const tokenTimestamp = Date.now();
                    
                    localStorage.setItem('spotify_access_token', accessToken);
                    localStorage.setItem('spotify_refresh_token', refreshToken);
                    localStorage.setItem('spotify_token_timestamp', tokenTimestamp);
                    localStorage.setItem('spotify_token_expires_in', expiresIn);
                    
                    // Show player UI
                    loginContainer.style.display = 'none';
                    playerContainer.style.display = 'block';
                    
                    // Set up player
                    setupPlayer(accessToken);
                    return;
                } catch (error) {
                    console.error('Error exchanging code for token:', error);
                    alert(`Authentication error: ${error.message}`);
                }
            }
            
            // If no code in URL, check if we have a valid stored token
            const storedToken = localStorage.getItem('spotify_access_token');
            const storedTimestamp = localStorage.getItem('spotify_token_timestamp');
            const storedExpiresIn = localStorage.getItem('spotify_token_expires_in');
            
            if (storedToken && storedTimestamp && storedExpiresIn) {
                const now = Date.now();
                const elapsed = (now - storedTimestamp) / 1000;
                
                if (elapsed < storedExpiresIn) {
                    // Token still valid
                    loginContainer.style.display = 'none';
                    playerContainer.style.display = 'block';
                    
                    // Set up player
                    setupPlayer(storedToken);
                    return;
                } else {
                    // Token expired, try to refresh it
                    try {
                        await refreshAccessToken();
                        
                        // If refresh successful, set up player
                        loginContainer.style.display = 'none';
                        playerContainer.style.display = 'block';
                        
                        setupPlayer(localStorage.getItem('spotify_access_token'));
                        return;
                    } catch (error) {
                        console.error('Error refreshing token:', error);
                        // If refresh fails, we'll continue to show login screen
                    }
                }
            }
            
            // If we reach here, we need to login again
            loginContainer.style.display = 'block';
            playerContainer.style.display = 'none';
        }
        
        // Refresh the access token using the refresh token
        async function refreshAccessToken() {
            const clientId = localStorage.getItem('spotify_client_id');
            const refreshToken = localStorage.getItem('spotify_refresh_token');
            
            if (!clientId || !refreshToken) {
                throw new Error('Missing client ID or refresh token');
            }
            
            const params = new URLSearchParams();
            params.append('client_id', clientId);
            params.append('grant_type', 'refresh_token');
            params.append('refresh_token', refreshToken);
            
            const response = await fetch(SPOTIFY_TOKEN_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: params
            });
            
            if (!response.ok) {
                throw new Error(`Refresh token request failed: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Update stored tokens
            localStorage.setItem('spotify_access_token', data.access_token);
            localStorage.setItem('spotify_token_timestamp', Date.now());
            localStorage.setItem('spotify_token_expires_in', data.expires_in);
            
            // If a new refresh token is provided, update it
            if (data.refresh_token) {
                localStorage.setItem('spotify_refresh_token', data.refresh_token);
            }
            
            return data;
        }
        
        // Format time from ms to M:SS
        function formatTime(ms) {
            if (isNaN(ms) || ms < 0) return "0:00";
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        // Global state for volume
        let currentVolumeBeforeMute = 50; // Default volume to restore to if unmuting from 0
        let isCurrentlyMuted = false;

        // Track state to avoid unnecessary UI updates
        let currentTrackId = null;
        let currentPlayState = null;
        let currentAlbumId = null; // Added to track current album for art caching
        let currentProgressMs = 0; // To track progress for polling activity

        // Set up player functionality
        function setupPlayer(token) {
            // Set up event listeners for player controls
            prevButton.addEventListener('click', () => {
                spotifyApiCall('POST', '/me/player/previous');
                setTimeout(getCurrentlyPlaying, 500);
            });
            
            playButton.addEventListener('click', () => {
                spotifyApiCall('PUT', '/me/player/play');
                setTimeout(getCurrentlyPlaying, 500);
            });
            
            pauseButton.addEventListener('click', () => {
                spotifyApiCall('PUT', '/me/player/pause');
                setTimeout(getCurrentlyPlaying, 500);
            });
            
            nextButton.addEventListener('click', () => {
                spotifyApiCall('POST', '/me/player/next');
                setTimeout(getCurrentlyPlaying, 500);
            });
            
            progressBar.addEventListener('input', () => {
                // Optional: Could provide visual feedback while dragging
                // For now, we only seek when the user releases (change event)
            });

            progressBar.addEventListener('change', () => {
                const newPosition = parseInt(progressBar.value);
                spotifyApiCall('PUT', `/me/player/seek?position_ms=${newPosition}`);
                // Update UI optimistically or wait for polling
                setTimeout(getCurrentlyPlaying, 250); // Quicker update after seek
            });
            
            muteToggleButton.addEventListener('click', async () => {
                let targetVolume;
                if (isCurrentlyMuted) {
                    targetVolume = currentVolumeBeforeMute > 0 ? currentVolumeBeforeMute : 50; // Restore or default
                    muteToggleButton.textContent = 'Mute'; // Immediately update UI
                    isCurrentlyMuted = false; // Immediately update state
                } else {
                    // Before muting, store current volume
                    const playerData = await spotifyApiCall('GET', '/me/player');
                    if (playerData && playerData.device && typeof playerData.device.volume_percent !== 'undefined') {
                        currentVolumeBeforeMute = playerData.device.volume_percent;
                    }
                    targetVolume = 0;
                    muteToggleButton.textContent = 'Unmute'; // Immediately update UI
                    isCurrentlyMuted = true; // Immediately update state
                }
                await spotifyApiCall('PUT', `/me/player/volume?volume_percent=${targetVolume}`);
                setTimeout(getCurrentlyPlaying, 250); // Refresh state from API
            });
            
            // Fullscreen toggle functionality
            fullscreenButton.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    if (playerContainer.requestFullscreen) {
                        playerContainer.requestFullscreen();
                    } else if (playerContainer.webkitRequestFullscreen) { /* Safari */
                        playerContainer.webkitRequestFullscreen();
                    } else if (playerContainer.msRequestFullscreen) { /* IE11 */
                        playerContainer.msRequestFullscreen();
                    }
                    fullscreenButton.textContent = 'Exit Fullscreen';
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) { /* Safari */
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { /* IE11 */
                        document.msExitFullscreen();
                    }
                    fullscreenButton.textContent = 'Fullscreen';
                }
            });
            
            // Start polling for current track
            getCurrentlyPlaying();
            
            // Adaptive polling - increase interval when inactive
            let pollingInterval = 3000; // Start with 3 seconds
            const maxPollingInterval = 10000; // Max 10 seconds between polls
            let inactiveTime = 0;
            
            function adaptivePolling() {
                getCurrentlyPlaying()
                    .then(hasActivity => {
                        // If track changed or playback state changed
                        if (hasActivity) {
                            inactiveTime = 0;
                            pollingInterval = 3000; // Reset to 3 seconds
                        } else {
                            inactiveTime += pollingInterval;
                            // Gradually increase polling interval when inactive
                            if (inactiveTime > 30000) { // After 30 seconds of inactivity
                                pollingInterval = Math.min(pollingInterval * 1.5, maxPollingInterval);
                            }
                        }
                        // Schedule next check
                        setTimeout(adaptivePolling, pollingInterval);
                    });
            }
            
            // Start adaptive polling
            adaptivePolling();
        }
        
        // Make API calls to Spotify
        async function spotifyApiCall(method, endpoint, body = null) {
            const token = localStorage.getItem('spotify_access_token');
            
            try {
                const response = await fetch(`${SPOTIFY_API_ENDPOINT}${endpoint}`, {
                    method: method,
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: body ? JSON.stringify(body) : null
                });
                
                if (response.status === 401) {
                    // Token expired
                    localStorage.removeItem('spotify_access_token');
                    alert('Your session has expired. Please log in again.');
                    window.location.reload();
                    return null;
                }
                
                if (response.status === 204) {
                    return true; // Success but no content
                }
                
                if (response.ok) {
                    // Only try to parse as JSON if there's content
                    if (response.status !== 204) {
                        const text = await response.text();
                        // Check if there's any content to parse
                        if (!text) return null;
                        
                        try {
                            // Check if the response starts with a valid JSON character
                            if (text.trim().startsWith('{') || text.trim().startsWith('[')) {
                                return JSON.parse(text);
                            } else {
                                console.log('Non-JSON response:', text);
                                return null;
                            }
                        } catch (parseError) {
                            console.error('JSON Parse Error:', parseError);
                            console.log('Response text:', text);
                            return null;
                        }
                    }
                    return true;
                } else {
                    console.error('API Error:', response.status);
                    return null;
                }
            } catch (error) {
                console.error('API Request Failed:', error);
                return null;
            }
        }
        
        // Get and display currently playing track
        async function getCurrentlyPlaying() {
            try {
                const data = await spotifyApiCall('GET', '/me/player/currently-playing');
                let activityDetectedForPolling = false;

                if (data) { // If data is not null (API call returned something)
                    // Always update mute button state if device info is available
                    if (data.device && typeof data.device.volume_percent !== 'undefined') {
                        const previousMuteState = isCurrentlyMuted;
                        const actualVolume = data.device.volume_percent;

                        if (actualVolume === 0) {
                            isCurrentlyMuted = true;
                            muteToggleButton.textContent = 'Unmute';
                            // currentVolumeBeforeMute retains its value from when it was last non-zero
                        } else {
                            isCurrentlyMuted = false;
                            muteToggleButton.textContent = 'Mute';
                            currentVolumeBeforeMute = actualVolume; // Store the current non-zero volume
                        }
                        if (isCurrentlyMuted !== previousMuteState) {
                            activityDetectedForPolling = true; // Mute state change is an activity
                        }
                    } else {
                        // console.log("Device or volume info missing in getCurrentlyPlaying response.");
                        // Potentially disable mute button or leave its state as is if no device info
                    }

                    // Handle track-specific information
                    if (data.item) {
                        const newTrackId = data.item.id;
                        const newAlbumId = data.item.album ? data.item.album.id : null;
                        const newPlayState = data.is_playing;
                        const newProgress = typeof data.progress_ms !== 'undefined' ? data.progress_ms : currentProgressMs;

                        const trackChanged = currentTrackId !== newTrackId;
                        const playStateChanged = currentPlayState !== newPlayState;
                        const albumChanged = newAlbumId !== currentAlbumId;
                        const progressChanged = currentProgressMs !== newProgress;


                        if (trackChanged || playStateChanged) {
                            trackName.textContent = data.item.name;
                            artistName.textContent = data.item.artists.map(artist => artist.name).join(', ');
                            currentTrackId = newTrackId;
                            currentPlayState = newPlayState;
                            activityDetectedForPolling = true;
                        }
                        
                        if (progressChanged || trackChanged) { // Update progress if it changed or track changed
                             if (data.item.duration_ms) {
                                progressBar.max = data.item.duration_ms;
                                totalTimeDisplay.textContent = formatTime(data.item.duration_ms);
                            }
                            progressBar.value = newProgress;
                            currentTimeDisplay.textContent = formatTime(newProgress);
                            currentProgressMs = newProgress;
                            if(progressChanged && !trackChanged && !playStateChanged) activityDetectedForPolling = true; // if only progress changed
                        }


                        if (newAlbumId && (albumChanged || !albumArt.hasChildNodes())) {
                            currentAlbumId = newAlbumId;
                            const albumArtCacheKey = `spotify_album_art_${newAlbumId}`;
                            let cachedArtUrl = localStorage.getItem(albumArtCacheKey);

                            if (cachedArtUrl) {
                                const img = new Image();
                                img.onload = () => {
                                    albumArt.innerHTML = `<img src="${cachedArtUrl}" alt="Album Art" style="width:100%; height:100%; border-radius:8px;">`;
                                };
                                img.onerror = () => {
                                    localStorage.removeItem(albumArtCacheKey);
                                    if (data.item.album) {
                                       fetchAndSetAlbumArt(data.item.album, newAlbumId);
                                    } else {
                                       albumArt.innerHTML = '';
                                    }
                                };
                                img.src = cachedArtUrl;
                            } else if (data.item.album && data.item.album.images && data.item.album.images.length > 0) {
                                fetchAndSetAlbumArt(data.item.album, newAlbumId);
                            } else {
                                albumArt.innerHTML = '';
                            }
                            activityDetectedForPolling = true;
                        }
                        // return activityDetectedForPolling || trackChanged || playStateChanged || albumChanged || progressChanged; // Consolidate activity
                        return activityDetectedForPolling;


                    } else if (currentTrackId !== null) { // Music stopped (no item, but was playing before)
                        currentTrackId = null;
                        currentPlayState = null;
                        currentAlbumId = null;
                        currentProgressMs = 0;
                        trackName.textContent = 'Not Playing';
                        artistName.textContent = '-';
                        albumArt.innerHTML = '';
                        progressBar.value = 0;
                        progressBar.max = 0;
                        currentTimeDisplay.textContent = '0:00';
                        totalTimeDisplay.textContent = '0:00';
                        return true; // Activity detected - state changed to not playing
                    }
                } else if (data === null && currentTrackId !== null ) { // API call failed, but we thought it was playing
                     // If API call fails (data is null), and we thought a track was playing, treat as state change.
                    currentTrackId = null; // Reset to trigger login/refresh if needed by other logic
                    return true; // Indicate activity to potentially slow down polling or re-check auth
                }
                
                return activityDetectedForPolling; // Return if any activity (mute, track, playstate, album, progress) was detected
            } catch (error) {
                console.error('Error updating player:', error);
                return false; // No activity on error
            }
        }
        
        // Helper function to fetch, display, and cache album art
        function fetchAndSetAlbumArt(albumData, albumId) {
            if (albumData && albumData.images && albumData.images.length > 0) {
                const imageUrl = albumData.images[0].url;
                const albumArtCacheKey = `spotify_album_art_${albumId}`;

                const img = new Image();
                img.onload = () => {
                    albumArt.innerHTML = `<img src="${imageUrl}" alt="Album Art" style="width:100%; height:100%; border-radius:8px;">`;
                    try {
                        localStorage.setItem(albumArtCacheKey, imageUrl);
                    } catch (e) {
                        console.warn("Could not cache album art, localStorage might be full.", e);
                    }
                };
                img.onerror = () => {
                    console.error("Failed to load album art image:", imageUrl);
                    albumArt.innerHTML = ''; // Clear art on error
                };
                img.src = imageUrl;
            } else {
                albumArt.innerHTML = ''; // No art available for this album
            }
        }
        
        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
